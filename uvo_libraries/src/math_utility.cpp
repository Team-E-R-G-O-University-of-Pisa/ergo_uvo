#include "uvo_libraries/math_utility.h"


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////// FUNCTIONS //////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void check_rotation_matrix(Mat &matrix)
{
    if(!isRotationMatrix(matrix))
    {
        Mat w, U, Vt;
        SVDecomp(matrix, w, U, Vt);
        matrix = U * Vt;
    }
}


// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


Mat compute_jacobian(geometry_msgs::Vector3 rpy)
{
    return (Mat1d(3, 3) << 1, sin(rpy.x)*tan(rpy.y), cos(rpy.x)*tan(rpy.y), 0, cos(rpy.x), -sin(rpy.x), 0, sin(rpy.x)/cos(rpy.y), cos(rpy.x)/cos(rpy.y));
}

// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


vector<double> compute_mean_and_variance(Mat v)
{
    CV_Assert((v.cols == 1) && (v.type() == CV_64F) && (v.rows > 0));
    int N = v.rows;

    double sum = 0.0;
    double sumOfSquares = 0.0;

    for (int i = 0; i < N; i++)
    {
        double value = v.at<double>(i);
        sum += value;
        sumOfSquares += value * value;
    }

    double mean = sum / N;
    double variance = (sumOfSquares / N) - (mean * mean);

    vector<double> statistic_values{mean, variance};

    return statistic_values;
}



// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


double compute_median(vector<double> v)
{
    size_t size = v.size();

    if (size == 0)
    {
        ROS_ERROR("Empty vector");
        return 0.0;
    }

    sort(v.begin(), v.end());

    if (size % 2 == 0)
    {
        size_t mid = size / 2;
        return (v[mid - 1] + v[mid]) / 2.0;
    }
    else
    {
        return v[size / 2];
    }
}


// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


Mat cross_product(Mat first_vector, Mat second_vector)
{
    CV_Assert(first_vector.rows == 3 && first_vector.cols == 1 && second_vector.rows == 3 && second_vector.cols == 1);

    double m1 = first_vector.at<double>(0, 0);
    double m2 = first_vector.at<double>(1, 0);
    double m3 = first_vector.at<double>(2, 0);

    double n1 = second_vector.at<double>(0, 0);
    double n2 = second_vector.at<double>(1, 0);
    double n3 = second_vector.at<double>(2, 0);

    double element1 = m2 * n3 - m3 * n2;
    double element2 = m3 * n1 - m1 * n3;
    double element3 = m1 * n2 - m2 * n1;

    return (Mat_<double>(3, 1) << element1, element2, element3);
}


// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


Mat from_euler_angles_to_quaternion(double roll, double pitch, double yaw)
{
    double cr = cos(roll * 0.5);
    double sr = sin(roll * 0.5);
    double cp = cos(pitch * 0.5);
    double sp = sin(pitch * 0.5);
    double cy = cos(yaw * 0.5);
    double sy = sin(yaw * 0.5);

    Mat q = (Mat1d(4,1) << cr*cp*cy + sr*sp*sy, sr*cp*cy - cr*sp*sy, cr*sp*cy + sr*cp*sy, cr*cp*sy - sr*sp*cy);

    return q;
}

// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


geometry_msgs::Vector3 from_mat_to_vector_type(Mat pos_mat)
{
    geometry_msgs::Vector3 pos;
    pos.x = pos_mat.at<double>(0);
    pos.y = pos_mat.at<double>(1);
    pos.z = pos_mat.at<double>(2);

    return pos;
} 


// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


Mat from_ros_to_cv_image(const sensor_msgs::CompressedImage::ConstPtr& image)
{
    cv_bridge::CvImagePtr cv_ptr;

    try
    {
        cv_ptr = cv_bridge::toCvCopy(image);
        if (image->format.find("bayer") != std::string::npos)
        {
            cvtColor(cv_ptr->image, cv_ptr->image, COLOR_BayerBGGR2BGR);
        }
    }

    catch(cv_bridge::Exception& e)
    {
        ROS_ERROR("cv_bridge exception: %s", e.what());
    }

    return cv_ptr->image;
}


// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


geometry_msgs::Vector3 from_rotation_matrix_to_euler_angles(Mat &R)
{
    check_rotation_matrix(R);

    geometry_msgs::Vector3 angles;

    double r11 = R.at<double>(0, 0);
    double r12 = R.at<double>(0, 1);
    double r21 = R.at<double>(1, 0);
    double r22 = R.at<double>(1, 1);
    double r23 = R.at<double>(1, 2);
    double r31 = R.at<double>(2, 0);
    double r32 = R.at<double>(2, 1);
    double r33 = R.at<double>(2, 2);

    double sy = sqrt(r11 * r11 + r21 * r21);

    bool singular = sy < 1e-6;

    if (!singular)
    {
        angles.x = atan2(r32, r33);
        angles.y = atan2(-r31, sy);
        angles.z = atan2(r21, r11);
    }
    else
    {
        ROS_ERROR("ROTATION MATRIX IS CLOSE TO SINGULARITY!!!");
        angles.x = atan2(-r23, r22);
        angles.y = atan2(-r31, sy);
        angles.z = 0;
    }

    return angles;
}


// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


Mat from_vector_to_mat_type(geometry_msgs::Vector3 vec)
{
    return (Mat1d(3, 1) << vec.x, vec.y, vec.z);
}


// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


Mat from_vector_to_skew_matrix(geometry_msgs::Vector3 vec)
{
    return (Mat1d(3, 3) << 0, vec.z, -vec.y, -vec.z, 0, vec.x, vec.y, -vec.x, 0);
}


// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


bool isRotationMatrix(Mat &R)
{
    // Checks if a matrix is a valid rotation matrix.
    Mat Rt;
    transpose(R, Rt);
    Mat shouldBeIdentity = Rt * R;
    Mat I = Mat::eye(3,3, shouldBeIdentity.type());

    return  norm(I, shouldBeIdentity) < 1e-6;
}


// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


geometry_msgs::Vector3 ll2ne(geometry_msgs::Vector3 ll0, geometry_msgs::Vector3 ll)
{      
  double lat0 = ll0.x;
  double lon0 = ll0.y;
  double lat  = ll.x;
  double lon  = ll.y;

  geometry_msgs::Vector3 ne;

  lat   = lat * M_PI/180;
  lon   = lon * M_PI/180;
  lat0  = lat0 * M_PI/180;
  lon0  = lon0 * M_PI/180;

  double dlat = lat - lat0;
  double dlon = lon - lon0;

  double a = 6378137.0;
  double f = 1 / 298.257223563;
  double Rn = a / sqrt(1 - (2 * f - f * f) * sin(lat0) * sin(lat0));
  double Rm = Rn * (1 - (2 * f - f * f)) / (1 - (2 * f - f * f) * sin(lat0) * sin(lat0));

  ne.x = dlat / atan2(1, Rm);
  ne.y = dlon / atan2(1, Rn * cos(lat0));

  return ne;      
}


// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


geometry_msgs::Vector3 lld2ned(geometry_msgs::Vector3 lld0, geometry_msgs::Vector3 lld) 
{
    geometry_msgs::Vector3 ned;
    geometry_msgs::Vector3 ne;

    ne = ll2ne(lld0, lld);

    ned.x = ne.x;
    ned.y = ne.y;
    ned.z = lld.z - lld0.z;

    return ned;
}


// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


geometry_msgs::Vector3 ne2ll(const geometry_msgs::Vector3 ll0, const geometry_msgs::Vector3 ne)
{
  double lat0 = ll0.x;
  double lon0 = ll0.y;

  geometry_msgs::Vector3 ll;

  lat0 = lat0 * M_PI/180;
  lon0 = lon0 * M_PI/180;

  double a  = 6378137.0;
  double f  = 1 / 298.257223563;
  double Rn = a / sqrt(1 - (2 * f - f * f) * sin(lat0) * sin(lat0));
  double Rm = Rn * (1 - (2 * f - f * f)) / (1 - (2 * f - f * f) * sin(lat0) * sin(lat0));

  ll.x = (lat0 + atan2(1, Rm)*ne.x) * 180/M_PI;
  ll.y = (lon0 + atan2(1, Rn*cos(lat0)) * ne.y) * 180/M_PI;

  return ll;
}


// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


Mat rotx(double angle)
{
    return (Mat1d(3, 3) << 1, 0, 0, 0, cos(angle), -sin(angle), 0, sin(angle), cos(angle));
}


// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


Mat roty(double angle)
{
    return (Mat1d(3, 3) << cos(angle), 0, sin(angle), 0, 1, 0, -sin(angle), 0, cos(angle));
}


// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


Mat rotz(double angle)
{
    return (Mat1d(3, 3) << cos(angle), -sin(angle), 0, sin(angle), cos(angle), 0, 0, 0, 1);
}


// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


Mat transform_coordinates(Mat vector, Mat R, Mat t)
{
    return R*vector + t;
}


// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //


double wrap2pi(double angle)
{
    return atan2(sin(angle), cos(angle));
}


// #################################################################################################### //
// #################################################################################################### //
// #################################################################################################### //